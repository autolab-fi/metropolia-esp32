# Description

Эта папка в полном объеме будет скачана на устройство, которое занимается автоматической проверкой.

## Структура

Название каждой функции проверки должно совпадать с полем `str_id` указанным в json файле `lessons_list.json`. При этом каждая функция проверки должна находится
в python файле, название которого должно совпадать с `str_id` модуля, указанного в json файле `lessons_list.json`.

Пример:
В файле `lessons_list.json` первый модуль под названием "Introduction to the Robot" имеет поле `str_id`, значение которого `module_0`. Соответственно в 
этой директории содержится файл `module_0.py`. Также в файле `lessons_list.json` внутри модуля под название "Introduction to the Robot" содержится список
`lessons`, содержащий несколько уроков с полями `str_id` равными: `draw`, `test_drive`, `license_to_drive`. В файле `module_0.py` содержатся функции с соответствующими именами. Эти функции будут использовать устройством, которое занимается авто-проверками.

## Описание функции проверки

Функция проверки вызывается на каждом кадре полученном с камеры.

Аргументы, которые передаются в функцию проверки:
+
- `robot` - ссылка на объект `robot`, который обладает своими 
методами, которые могут быть использованы внутри функций проверок. Подробнее о методах объекта робот можно прочитать [здесь](#объект-робот)
- `image` - это изображение с камеры, объект типа `numpy.ndarray`. Изображение в формате RGB.
- `td` - словарь, содержащий разные параметры, необходимые для функции проверки, объект типа `dict`. При первом вызове функции равен `None`

Функция возвращает:

- `image` - модифицированное изображение внутри функции проверки, которое будет транслировано пользователю, объект типа `numpy.ndarray`. Изображение в формате RGB.
- `td`- словарь, содержащий разные параметры, необходимые для функции проверки, объект типа `dict`. В этом словаре можно хранить данные, которые будут 
использованы на следующих итерациях функции проверки. **Обязательно** в этом словаре должно быть поле **`end_time`**, которое указывает, когда проверка завершится.
- `text`- это текст сообщения, которое будет выведено пользователю, поле типа string
- `result` - словарь, содержащий результаты итерации проверки. В этом словаре должны быть следующие **обязательные** поля: 
    - **`success`** - поле типа boolean, если это поле равно `False`, то задание считается проваленным и проверка сразу завершается.
    - **`description`** - это описание результата, будет выведено пользователю после завершения проверки. Поле типа string
    - **`score`** - это оценка за задние в пределах от 0 до 100, где 0 - это задание провалено, 100 - задание выполнено на отлично.

## Дополнительные обязательные данные в файлах модулей.

В каждом файле модуля помимо функции проверки и вспомогательных функций для них должны **обязательно** быть:

1) Словарь содержащий стартовые позиции для каждого задания. Каждая стартовая позиция описывается двумя кортежами: первый - позиция в сантиметрах на поле; второй -
    это направление робота, направляющая точка рассчитывается как: координата x робота + первое значение из кортежа направления, координата y робота + второе значение 
    из кортежа направления. Ключами словаря являются `str_id` заданий из списка `lessons_list.json`.
    
    Пример расчета направляющей точки:
    Пусть для задания 'test_drive' имеем список из двух точек: [(35, 50), (30, 0)]. Где (35, 50) - стартовая точка, на которую поедет робот. (30, 0) - направление робота.
    Когда робот приедет на стартовую точку, его координата будет примерно совпадать с точкой (35, 50). Соответственно направляющая точка будет рассчитана так: (35+30, 50+0),
    значит робот будет направлен в сторону точки (35+30, 50+0), то есть в положительном направлении оси x.

    Пример словаря со стартовыми точками: 
    ```python
    # start points for the tasks
    target_points = {
        'test_drive': [(35, 50), (30, 0)],
        'license_to_drive': [(35, 50), (30, 0)],
        'draw': [(50, 50), (30, 0)]
    }
    ```

2) Словарь содержащий информацию о блокировании функций библиотек. Это необходимо для предотвращения жульничества. Пример: задание курса заключается в том, чтобы
    пользователь написал функцию движения робота, но пользователь может попробовать использовать стандартную функцию библиотеки для движения. В связи с этим вводится
    блокировка. Если значение в этом словаре будет `True`, то стандартные функции библиотеки будут заблокированы. Какие функции будут заблокированы, можно посмотреть в библиотеке для робота. Ключами словаря являются `str_id` заданий из списка `lessons_list.json`.

    Пример такого словаря:

    ```python
    block_library_functions = {
        'test_drive': False,
        'license_to_drive': False,
        'draw': False,
    }
    ```

3) Функция, которая возвращает значение из словаря 1. Функция приведенная ниже просто может быть скопирована в файл модуля.

    ```python
    # function to get value from dictionary target_point
    def get_target_points(task):
        global target_points
        return target_points[task]
    ```

4) Функция, которая возвращает значение из словаря 2. Функция приведенная ниже просто может быть скопирована в файл модуля.

    ```python
    # function to get value from dictionary block_library_functions
    def get_block_library_functions(task):
        global block_library_functions
        return block_library_functions[task]
    ```


## Объект робот

Объект `robot` представляет собой экземпляр класса `RobotESP32_MQTT`, который используется для управления и взаимодействия с роботом на полигоне. Этот класс предоставляет методы и поля для получения информации о роботе. Посмотреть на исходные файлы можно [здесь](https://github.com/autolab-fi/lineRobot-cpp-worker/blob/main/src/RobotESP32MQTT.py)(при наличии соответсвующего доуступа к репозиторию).


### Поля объекта

- **`name`** (`str`): Название робота на полигоне.
- **`model`** (`str`): FQBN (Fully Qualified Board Name) платы робота. Для данного робота это значение всегда `esp32:esp32:nodemcu-32s`.
- **`user`** (`str`): Имя пользователя, код которого в данный момент проверяется.
- **`status`** (`str`): Текущий статус робота. Возможные значения: `"Online"` (подключен) и `"Offline"` (не подключен).
- **`position`** (`tuple[float, float]`): Позиция робота в сантиметрах. Точка соответствует центру apriltag, закрепленного на роботе.
- **`position_px`** (`tuple[int, int]`): Позиция робота в пикселях на изображении. Точка соответствует центру apriltag.
- **`top_right`** (`tuple[float, float]`): Правый верхний угол apriltag в сантиметрах.
- **`top_left`** (`tuple[float, float]`): Левый верхний угол apriltag в сантиметрах.
- **`bottom_left`** (`tuple[float, float]`): Левый нижний угол apriltag в сантиметрах.
- **`bottom_right`** (`tuple[float, float]`): Правый нижний угол apriltag в сантиметрах.
- **`top_right_px`** (`tuple[int, int]`): Правый верхний угол apriltag в пикселях.
- **`top_left_px`** (`tuple[int, int]`): Левый верхний угол apriltag в пикселях.
- **`bottom_left_px`** (`tuple[int, int]`): Левый нижний угол apriltag в пикселях.
- **`bottom_right_px`** (`tuple[int, int]`): Правый нижний угол apriltag в пикселях.

### Методы объекта

#### `get_info() -> Dict[str, Any]`
Возвращает словарь с информацией о роботе. Все данные в словаре соответствуют полям объекта.

**Возвращаемое значение:**
```json
{
    "name": name,
    "position": position,
    "position_px": position_px,
    "direction": compute_angle_x(),
    "firmware_version": firmware_version,
    "top_right": top_right,
    "top_left": top_left,
    "bottom_left": bottom_left,
    "bottom_right": bottom_right,
    "top_right_px": top_right_px,
    "top_left_px": top_left_px,
    "bottom_left_px": bottom_left_px,
    "bottom_right_px": bottom_right_px
}
```

Все поля относящиеся к положению робота могут иметь значение **`None`**, если робот не был найден на избражении.


#### `get_msg() -> Optional[str]`
Получает сообщение из пользовательского MQTT-топика. Если в коде для робота была использована функция `printMQTT`, то сообщение можно прочитать с помощью этого метода. Сообщения помещаются в очередь размером 10 элементов. Если очередь переполняется, самое старое сообщение удаляется.

**Важно:** Сообщения не могут быть прочитаны быстрее чем 10 раз в секунду(а более вероятна скорость чтения 6-7 раз в секунду). Рекомендуется использовать задержки (например, 200-500 мс) в коде пользователя.

#### `pixels_to_cm(pixels: float) -> float`
Переводит значение из пикселей в сантиметры.

**Аргументы:**
- `pixels` (`float`): Значение в пикселях.

**Возвращаемое значение:**
- `float`: Значение в сантиметрах.

#### `cm_to_pixel(cm: float) -> int`
Переводит значение из сантиметров в пиксели.

**Аргументы:**
- `cm` (`float`): Значение в сантиметрах.

**Возвращаемое значение:**
- `int`: Значение в пикселях.

#### `create_vector(point_0: Tuple[float, float], point_1: Tuple[float, float]) -> Tuple[float, float]`
Создает вектор на плоскости из двух точек.

**Аргументы:**
- `point_0` (`Tuple[float, float]`): Начальная точка.
- `point_1` (`Tuple[float, float]`): Конечная точка.

**Возвращаемое значение:**
- `Tuple[float, float]`: Вектор, представленный как кортеж из двух чисел с плавающей точкой.

#### `angle_of_vectors(vec_0: Tuple[float, float], vec_1: Tuple[float, float]) -> float`
Возвращает угол между двумя векторами.

**Аргументы:**
- `vec_0` (`Tuple[float, float]`): Первый вектор.
- `vec_1` (`Tuple[float, float]`): Второй вектор.

**Возвращаемое значение:**
- `float`: Угол между векторами в градусах.

#### `mid_point(point_0: Tuple[float, float], point_1: Tuple[float, float]) -> Tuple[float, float]`
Возвращает среднюю точку между двумя точками.

**Аргументы:**
- `point_0` (`Tuple[float, float]`): Первая точка.
- `point_1` (`Tuple[float, float]`): Вторая точка.

**Возвращаемое значение:**
- `Tuple[float, float]`: Средняя точка.

#### `compute_angle_robot_point(point: Tuple[float, float]) -> float`
Вычисляет угол между текущим направлением робота и вектором, направленным на заданную точку.

**Аргументы:**
- `point` (`Tuple[float, float]`): Точка, на которую направлен вектор.

**Возвращаемое значение:**
- `float`: Угол в градусах.

#### `compute_angle(vec: Tuple[float, float]) -> float`
Вычисляет угол между текущим направлением робота и заданным вектором.

**Аргументы:**
- `vec` (`Tuple[float, float]`): Вектор, с которым вычисляется угол.

**Возвращаемое значение:**
- `float`: Угол в градусах.

#### `compute_angle_x() -> float`
Вычисляет угол между текущим направлением робота и осью X.

**Возвращаемое значение:**
- `float`: Угол в градусах.

#### `draw_frame(image: numpy.ndarray) -> numpy.ndarray`
Рисует рамку вокруг apriltag и точку по центру на изображении с использованием OpenCV.

**Аргументы:**
- `image` (`numpy.ndarray`): Входное изображение.

**Возвращаемое значение:**
- `numpy.ndarray`: Изображение с нарисованной рамкой и точкой.

#### `draw_info(image: numpy.ndarray) -> numpy.ndarray`
Рисует графику поверх изображения, включая рамку вокруг apriltag, текущее время в UTC, статус робота, имя пользователя и положение робота в пространстве.

**Аргументы:**
- `image` (`numpy.ndarray`): Входное изображение.

**Возвращаемое значение:**
- `numpy.ndarray`: Изображение с нарисованной информацией.

#### `delta_points(point_0: Tuple[float, float], point_1: Tuple[float, float]) -> float`
Вычисляет расстояние между двумя точками на плоскости.

**Аргументы:**
- `point_0` (`Tuple[float, float]`): Первая точка.
- `point_1` (`Tuple[float, float]`): Вторая точка.

**Возвращаемое значение:**
- `float`: Расстояние между точками.


## Пример реализации функции проверки


```python
def task_test(robot, image, td: dict):
    # init result structure
    result = {"success": True, "description": "You are amazing! The Robot has completed the assignment", "score": 100}
    # init text for user
    text = "Not recognized"

    # init test data structure
    if not td:
        td = {"end_time": time.time() + 20}

    # draw basic info about robot, verification and user
    image = robot.draw_info(image)

    # get info about the robot
    info = robot.get_info()
    robot_position_px = info['position_px']
    robot_position = info['position']

    # print robot position if it is found on the image
    if robot_position is not None:
        text = f'Robot position: x: {robot_position[0]:0.1f} y: {robot_position[1]:0.1f}'

    # get message from the robot and display to user if it is not none
    msg = robot.get_msg()
    if msg is not None:
        text = f"Message received: {msg}"

    # NB: return IMAGE
    return image, td, text, result
```

- Инициализация структуры описывющей результаты проверки. Как можно видеть, далее в коде нигде не переопределяются значения в этой структуре, поэтому эта проверка всегда будет заврещатся успехом. Подробнее о структуре [здесь](#описание-функции-проверки).

    ```python
    result = {"success": True, "description": "You are amazing! The Robot has completed the assignment", "score": 100}
    ```

- Инициализация текста для пользователя, который будет выведен, если робот не будет найден на изображении и если не будет получено никаких сообщений из MQTT.

    ```python
    text = "Not recognized"
    ```

- Инициализация структуры td, которая может хранить значения, необходимые для проверки. Подробнее о структуре [здесь](#описание-функции-проверки).

    ```python
    if not td:
        td = {"end_time": time.time() + 20}
    ```

- Нарисовать графику поверх изображения. Подробнее [здесь](#draw_infoimage-numpyndarray---numpyndarray).

    ```python
    image = robot.draw_info(image)
    ```

- Получение информации о текущем положении робота. Подробнее [здесь](#get_info---dictstr-any).

    ```python
    info = robot.get_info()
    robot_position_px = info['position_px']
    robot_position = info['position']
    ```

- Проверка, что робот был найден на изображении

    ```python
    if robot_position is not None:
        text = f'Robot position: x: {robot_position[0]:0.1f} y: {robot_position[1]:0.1f}'
    ```

- Чтение пользовательского сообещения, отправленного с помощью `printMQTT`. Подробнее [здесь](#get_msg---optionalstr).

    ```python
    msg = robot.get_msg()
    if msg is not None:
        text = f"Message received: {msg}"
    ```

- Функция возвращает **4** параметра, обязательно в этом порядке

    ```python
    return image, td, text, result
    ```